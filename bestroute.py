import numpy as np
import scipy.io

from calcweight import find_n, find_two_list, calc_weight

# correspond to correct order of graph's inner list
NEXT_NODE = 0
WEIGHT = 1
TIME = 2
IMP = 3
COST = 4
DISTANCE = 5

def generate_weight(time_arr, imp_arr, cost_arr, time=0, imp=0, cost=0):
    """
    Generate one array of weights based off of 3 separate weightings and a value given to each one,
    on a scale from 0 - 100
    """
    return [sum(x) for x in zip(np.multiply(time_arr, time),
                                np.multiply(imp_arr, imp),
                                np.multiply(cost_arr, cost)
                                )]

def normalize_weights(time_arr, imp_arr, cost_arr):
    """
    Normalizes the three weight arrays
    """
    tot_time = sum(time_arr)
    tot_imp = sum(imp_arr)
    tot_cost = sum(cost_arr)
    time_norm = []
    imp_norm = []
    cost_norm = []
    for index in range(len(time_arr)):
        time_norm.append(time_arr[index] / tot_time)
        imp_norm.append(imp_arr[index] / tot_imp)
        cost_norm.append(cost_arr[index] / tot_cost)
    return time_norm, imp_norm, cost_norm

def construct_graph(a, b, w, time_arr, imp_arr, cost_arr, dist_arr):
    """
    Creates a representation of a graph out of two lists of nodes (a and b) and a list of the
    weights between them. The graph is a dictionary where each key is a node, and the corresponding
    value is a list of lists, where each inner list is represented as [neighbor node, weight to node].
    """
    graph = {}
    for index,nodes in enumerate(zip(a,b)):
        # add unadded nodes to graph's keys with empty list
        if nodes[0] not in graph.keys():
            graph[nodes[0]] = []
        if nodes[1] not in graph.keys():
            graph[nodes[1]] =  []
        # add unadded destination nodes as list [dest, weight]
        if nodes[1] not in graph[nodes[0]]:
            graph[nodes[0]].append([nodes[1], w[index], time_arr[index], imp_arr[index], cost_arr[index], dist_arr[index]])
        if nodes[0] not in graph[nodes[1]]:
            graph[nodes[1]].append([nodes[0], w[index], time_arr[index], imp_arr[index], cost_arr[index], dist_arr[index]])
    return graph

def dijkstra(graph, start):
    """
    Takes the graph generated by construct_graph, one start point.
    Implements Dijkstra's algorithm and the pseudocode given here:
    https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
    to return two dictionaries, dist and prev.
    dist: the shortest distance from the start point to each respective node
    prev: the previous node on the shortest path from the start to that node
    """
    unvisited = []
    weight = {}
    prev = {}
    time = {}
    imp = {}
    cost = {}
    dist = {}
    for node in graph.keys():
        # add all nodes to 'unvisited' with no previous node and a weight of infinity
        unvisited.append(node)
        weight[node] = float('inf')
        time[node] = float('inf')
        imp[node] = float('inf')
        cost[node] = float('inf')
        dist[node] = float('inf')
        prev[node] = None

    # set the starting distance to be 0
    weight[start] = 0
    time[start] = 0
    imp[start] = 0
    cost[start] = 0
    dist[start] = 0

    # iterate until no node is left unvisited
    while len(unvisited) > 0:
        # get the lowest distance that has not yet been visited
        curr_node = min(weight.viewkeys() & unvisited, key=weight.get)
        # mark the node as visited
        unvisited.remove(curr_node)
        # iterate through each neighbor of the current node
        for neighbor in graph[curr_node]:
            # calculate distance to that node from this node
            tmp_weight = weight[curr_node] + neighbor[WEIGHT]
            tmp_time = time[curr_node] + neighbor[TIME]
            tmp_imp= imp[curr_node] + neighbor[IMP]
            tmp_cost = cost[curr_node] + neighbor[COST]
            tmp_dist = dist[curr_node] + neighbor[DISTANCE]
            # if this distance is less than the one already stored at that node
            if tmp_weight < weight[neighbor[NEXT_NODE]]:
                # we store this distance as its distance,
                weight[neighbor[NEXT_NODE]] = tmp_weight
                time[neighbor[NEXT_NODE]] = tmp_time
                imp[neighbor[NEXT_NODE]] = tmp_imp
                cost[neighbor[NEXT_NODE]] = tmp_cost
                dist[neighbor[NEXT_NODE]] = tmp_dist
                # and this node as its previous node
                prev[neighbor[NEXT_NODE]] = curr_node

    return weight, prev, time, imp, cost, dist

def backtrack(start, end, prev):
    """
    Uses the prev dictionary generated by djikstra to trace a way back from the
    end point to the start point, and returns the path as a list
    """
    backtracked = False
    curr_node = end
    # instantiate path as list with destination only
    path = [curr_node]
    while not backtracked:
        # retrieve previous node
        prev_node = prev[curr_node]
        # insert it at beginning of path
        path.insert(0, prev_node)
        # move onto previous node as current node for next iteration
        curr_node = prev_node
        # break loop if we reached start
        if curr_node == start:
            backtracked = True
    return path

def bike_or_drive(timeweight, impweight, costweight, car_time, car_imp, car_cost, bike_time, bike_imp, bike_cost):
    """
    Takes in the consumer's weights in different areas, and bike and car values
    to determine biking of driving
    """
    time_diff_norm = (car_time - bike_time)/(car_time + bike_time)
    imp_diff_norm = (car_imp - bike_imp)/(car_imp + bike_imp)
    cost_diff_norm = (car_cost - bike_cost)/(car_cost + bike_cost)
    tot = timeweight * time_diff_norm + impweight * imp_diff_norm + costweight * cost_diff_norm
    if tot < 0:
        return 'drive'
    else:
        return 'bike'

if __name__ == '__main__':
    a  = [1 , 3, 3, 4 , 7 , 5 , 1 , 8 , 6, 7 , 7 , 13, 13, 11, 11, 1 , 10, 16, 14, 9 , 15, 12, 17, 18, 15]
    b  = [3 , 4, 5, 7 , 6 , 6 , 8 , 6 , 9, 9 , 13, 12, 18, 9 , 14, 10, 16, 14, 17, 15, 12, 2 , 2 , 2 , 17]
    distance  = [5 , 3, 2, 4 , 2 , 3 , 4 , 7 , 1, 3 , 8 , 4 , 2 , 5 , 4 , 10, 10, 7 , 8 , 8 , 4 , 3 , 4 , 4 , 4 ]

    car_time_mile = [2.2,2.3,4.5,4.75,5,3.3,3,2.3,4,3.3,2.75,4.75,3,1.6,3,1.4,1.5,1.1,2.13,2.25,4.25,1.7,4.75,2.75,1]
    car_imp_mile= [.35,.45,.35,.35 ,.35 , .45, .25, .35,.45,.35 ,.35 ,.35 ,.35 ,.35 ,.35 , .25, .25,.25 ,.35 ,.35 ,.35 ,.35 ,.35 ,.35 ,.35 ]
    car_cost_mile= [.2,.2,.2,.2 ,.2 , .2, .2, .2,.3,.2 ,.2 ,.2 ,.2 ,.2 ,.2 , .15, .1,.15 ,.2 ,.2 ,.2 ,.2 ,.2 ,.2 ,.2 ]

    bike_time_mile = [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4]
    bike_imp_mile = [.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1]
    bike_cost_mile = [.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005,.005]

    timeweight = 0
    impweight = 100
    costweight = 0

    car_time = np.multiply(distance, car_time_mile)
    car_imp = np.multiply(distance, car_imp_mile)
    car_cost = np.multiply(distance, car_cost_mile)
    car_time_norm, car_imp_norm, car_cost_norm = normalize_weights(car_time, car_imp, car_cost)

    bike_time = np.multiply(distance, bike_time_mile)
    bike_imp = np.multiply(distance, bike_imp_mile)
    bike_cost = np.multiply(distance, bike_cost_mile)
    bike_time_norm, bike_imp_norm, bike_cost_norm = normalize_weights(bike_time, bike_imp, bike_cost)

    car_weight = generate_weight(car_time_norm, car_imp_norm, car_cost_norm, timeweight, impweight, costweight)
    car_g = construct_graph(a, b, car_weight, car_time, car_imp, car_cost, distance)
    car_weighted, car_prev, car_time, car_imp, car_cost, car_dist = dijkstra(car_g, 1)
    car_path = backtrack(1, 2, car_prev)
    print 'Car path:', car_path
    print 'Time:', car_time[2]
    print 'Impact:', car_imp[2]
    print 'Cost:', car_cost[2]
    print 'Distance:', car_dist[2]

    bike_weight = generate_weight(bike_time_norm, bike_imp_norm, bike_cost_norm, 0, 100, 0)
    bike_g = construct_graph(a, b, bike_weight, bike_time, bike_imp, bike_cost, distance)
    bike_weighted, bike_prev, bike_time, bike_imp, bike_cost, bike_dist = dijkstra(bike_g, 1)
    bike_path = backtrack(1, 2, bike_prev)
    print 'Bike path:', bike_path
    print 'Time:', bike_time[2]
    print 'Impact:', bike_imp[2]
    print 'Cost:', bike_cost[2]
    print 'Distance:', bike_dist[2]

    print 'You should', bike_or_drive(timeweight, impweight, costweight,
    car_time[2], car_imp[2], car_cost[2],
    bike_time[2], bike_imp[2], bike_cost[2])
