import numpy as np
import scipy.io

from calcweight import find_n, find_two_list, calc_weight

# correspond to correct order of graph's inner list
NEXT_NODE = 0
WEIGHT = 1

def construct_graph(a,b,w):
    """
    Creates a representation of a graph out of two lists of nodes (a and b) and a list of the
    weights between them. The graph is a dictionary where each key is a node, and the corresponding
    value is a list of lists, where each inner list is represented as [neighbor node, weight to node].
    """
    graph = {}
    for index,nodes in enumerate(zip(a,b)):
        # add unadded nodes to graph's keys with empty list
        if nodes[0] not in graph.keys():
            graph[nodes[0]] = []
        if nodes[1] not in graph.keys():
            graph[nodes[1]] =  []
        # add unadded destination nodes as list [dest, weight]
        if nodes[1] not in graph[nodes[0]]:
            graph[nodes[0]].append([nodes[1],w[index]])
        if nodes[0] not in graph[nodes[1]]:
            graph[nodes[1]].append([nodes[0],w[index]])
    return graph

def dijkstra(graph, start):
    """
    Takes the graph generated by construct_graph, one start point.
    Implements Dijkstra's algorithm and the pseudocode given here:
    https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
    to return two dictionaries, dist and prev.
    dist: the shortest distance from the start point to each respective node
    prev: the previous node on the shortest path from the start to that node
    """
    unvisited = []
    dist = {}
    prev = {}
    for node in graph.keys():
        # add all nodes to 'unvisited' with no previous node and a weight of infinity
        unvisited.append(node)
        dist[node] = float('inf')
        prev[node] = None

    # set the starting distance to be 0
    dist[start] = 0

    # iterate until no node is left unvisited
    while len(unvisited) > 0:
        # get the lowest distance that has not yet been visited
        curr_node = min(dist.viewkeys() & unvisited, key=dist.get)
        # mark the node as visited
        unvisited.remove(curr_node)
        # iterate through each neighbor of the current node
        for neighbor in graph[curr_node]:
            # calculate distance to that node from this node
            tmp_dist = dist[curr_node] + neighbor[WEIGHT]
            # if this distance is less than the one already stored at that node
            if tmp_dist < dist[neighbor[NEXT_NODE]]:
                # we store this distance as its distance,
                dist[neighbor[NEXT_NODE]] = tmp_dist
                # and this node as its previous node
                prev[neighbor[NEXT_NODE]] = curr_node

    return dist, prev

def backtrack(start, end, prev):
    """
    Uses the prev dictionary generated by djikstra to trace a way back from the
    end point to the start point, and returns the path as a list
    """
    backtracked = False
    curr_node = end
    # instantiate path as list with destination only
    path = [curr_node]
    while not backtracked:
        # retrieve previous node
        prev_node = prev[curr_node]
        # insert it at beginning of path
        path.insert(0, prev_node)
        # move onto previous node as current node for next iteration
        curr_node = prev_node
        # break loop if we reached start
        if curr_node == start:
            backtracked = True
    return path


if __name__ == '__main__':
    a  = [1 , 3, 3, 4 , 7 , 5 , 1 , 8 , 6, 7 , 7 , 13, 13, 11, 11, 1 , 10, 16, 14, 9 , 15, 12, 17, 18, 15]
    b  = [3 , 4, 5, 7 , 6 , 6 , 8 , 6 , 9, 9 , 13, 12, 18, 9 , 14, 10, 16, 14, 17, 15, 12, 2 , 2 , 2 , 17]
    D  = [5 , 3, 2, 4 , 2 , 3 , 4 , 7 , 1, 3 , 8 , 4 , 2 , 5 , 4 , 10, 10, 7 , 8 , 8 , 4 , 3 , 4 , 4 , 4 ]
    g = construct_graph(a,b,D)
    # print g
    dist,prev = dijkstra(g, 1)
    # print dist
    # print prev
    print backtrack(1,2,prev), dist[2]
